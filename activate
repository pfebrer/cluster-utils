#!/bin/bash

# It is EXTREMELY IMPORTANT that we define the following alias, 
# since it will prevent accidental removal of all the files inside a mount.
# Without this protection, if one does "rm -r mounts/" and "mounts" contains 
# a mounted cluster, it would be catastrophic, as it would remove all the
# contents inside a cluster
# Note that we implement the extra protection of removing write permissions
# from the directory where all the mounts are, which will ask you if 
# you are sure to continue your recursive search (check cli/subcommands/mount).
alias rm="rm --one-file-system"
# We also define a function that does exactly the same because
# aliases are not transmitted to child processes, but exported functions do :)
# Note: we keep the alias because it's the only way of making it work with a
# sudo call (see below)
function rm(){ 
	command rm --one-file-system "$@" 
}
export -f rm

# Then we do this little trick so that sudo also sees the alias
# (check out https://askubuntu.com/a/22043)
alias sudo="sudo "

# Define the root so that everybody knows how to access files in the cluster-utils package
export CLUSTER_UTILS_ROOT=$(dirname $(realpath $BASH_SOURCE))

# Activate the clusterutils cli
source "$CLUSTER_UTILS_ROOT"/cli/activate

# Define also the place where the user scripts are expected to be
# (can be overwritten)
export CLUSTER_UTILS_USERSCRIPTS=$(clusterutils path user-scripts)

# Define the name of the host where we are running cluster-utils
export CLUSTER_UTILS_HOST=$(clusterutils gethost)

# Define the place where, by default, cluster-utils will mount clusters
export CLUSTER_UTILS_MOUNTS=$(clusterutils path mounts)

# Source all the files that contain commands to make them accessible
for f in $(clusterutils path commands/*); do
	source $f
done 

# Source all the helpers
for f in $(clusterutils path helpers/*); do
	source $f
done
